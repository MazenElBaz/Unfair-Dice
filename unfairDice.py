# ----------------------
# Name: Mazen ElBaz
# Date: Sept. 2018
# ----------------------

import random

""" Simulate n rolls of a biased m-sided die and return
    a list containing the results.

    Arguments:
        prob_list: a list of the probabilities of rolling the
                   number on each side of the m-sided die. The list
                   will always have the length m (m >= 2), where m is
                   the number of sides numbered 1 to m. Therefore,
                   for example, the probability stored at index 0 in
                   the list is the probability of rolling a 1 on
                   the m-sided die.
        s: the seed to use when initializing the PRNG
        n: the number of rolls to return

    Return:
        rolls: a list (of length n) containing each of the n rolls of the
               biased die, in the order they were generated. """


def biased_rolls(prob_list, s, n):

    mapping = []
    rolls = []
    index = 0
    probRange = 0

    random.seed(s)

    for element in prob_list:
        # this is done since the mapping list is an empty list. This allows
        # data to be stored in the newly created index which avoides an
        # index out of range error when run
        mapping.append(None)
        # this maps the propability of each side of the die to the mapping
        # list
        # Citation: the idea of how to map propabilities was discussed in
        # class
        mapping[index] = probRange + element
        probRange = probRange + element
        index = index + 1

    for roll in range(0, n):
        toss = random.random()
        for count in range(0, len(prob_list)):
            # this conditional statement checks to see where does the
            # floating point number stored in the variable toss lies in
            # the mapping list
            if toss < mapping[count]:
                # Since the list starts from index 0 but the sides of the
                # die are numbered from 1, plus 1 is used to make sure
                # that the side of the die that was rolled is the one
                # that is actually being added to the rolls list
                rolls.append(count + 1)
                break

    return rolls


""" Draws a frequency histogram of the rolls of an m-sided die
    mapped to a fixed width.

    Arguments:
        m (int): the number of sides on the die
        rolls (list): the list of rolls generated by the biased die
        width (int): the fixed width of the histogram, in characters
                     (this is the length of the longest bar in the
                     histogram, to maximize space in the chart)

    Returns:
        None (but prints the histogram to standard output) """


def draw_histogram(m, rolls, width):

    dieSides = []
    sidesFrequency = []
    extraDots = 0
    maxFrequency = 0
    frequency = 0
    scaledFrequency = 0

    for i in range(0, m):
        # empty strings are appended to sidesFrequency as a way to
        # initialize the histogram bar for each side of the die
        sidesFrequency.append('')
        # m sides of the die are appended to dieSides list
        dieSides.append(i+1)

    for turn in rolls:
        # for example if the roll was side 1, this concatenates
        # an asterisk to the empty string in index=1-1=0 of the
        # sidesFrequency list
        sidesFrequency[turn-1] = sidesFrequency[turn-1] + '*'

    # maxFrequency stores the frequency of the side of the die with the
    # highest frequency
    maxFrequency = len(max(sidesFrequency))

    # this conditional statement checks to see if the histrogram requires
    # scaling
    if (maxFrequency < width) or (maxFrequency > width):

        for z in range(0, m):

            # this variable stores the frequency of the side of the die
            # in index z of the sidesFrequency list
            frequency = len(sidesFrequency[z])
            # scaledFrequency stores the adjusted frequency of the side
            # of the die in index z of the sidesFrequency list
            scaledFrequency = round((frequency/maxFrequency) * width)

            # this while loop keeps concatenating asterisks until the
            # frequency of the side of the die has scaled up to the scaled
            # frequency
            while frequency < scaledFrequency:
                sidesFrequency[z] = sidesFrequency[z] + '*'
                frequency = frequency + 1

            # this while loop keeps removing asterisks until the
            # frequency of the side of the die has scaled down to the scaled
            # frequency
            while frequency > scaledFrequency:
                sidesFrequency[z] = \
                    sidesFrequency[z][0:len(sidesFrequency[z])-1]
                frequency = frequency - 1
    # str() is used to turn the integer m into a string literal so that it
    # it can be concatenated to another string literal
    print('Frequency Histogram:', str(m) + '-sided Die')

    for x in range(0, m):
        # this conditional statement checks to see if the bar is less than
        # the required width
        if len(sidesFrequency[x]) < width:
            # extraDots stores the number of dots needed to fill the bar
            # until it has the required width
            extraDots = width - len(sidesFrequency[x])
            # this for loop concatenates the extra needed dots
            for dot in range(0, extraDots):
                sidesFrequency[x] = sidesFrequency[x] + '.'
        print(str(x+1) + ':' + sidesFrequency[x])

    return None


if __name__ == "__main__":
    # Any code indented under this line will only be run
    # when the program is called directly from the terminal
    # using "python3 unfairDice.py". This can be useful for
    # testing your implementations.
    rolls = biased_rolls([1/12, 1/4, 1/3, 1/12, 1/12, 1/6], 2**32-1, 20)
    print(rolls)
    draw_histogram(6, rolls, 50)

    rolls = biased_rolls([1/4, 1/6, 1/12, 1/12, 1/4, 1/6], 42, 200)
    draw_histogram(6, rolls, 10)

    rolls = biased_rolls([1/3, 1/3, 1/3], 2**32-1, 1000)
    draw_histogram(3, rolls, 10)
